
userarr=("$@")
sstools_modifier=$1
#echo ${sstools_modifier}
#execute global config file to get most up to date configurations
#Not the most beautiful way to set an environmental variable but it works

CURDIR=`/bin/pwd`
BASEDIR=$(dirname $0)
ABSPATH=$(readlink -f $0)
ABSDIR=$(dirname $ABSPATH)

SSTOOLS_ROOT_ENV="${ABSDIR%/bin}"
export SSTOOLS_ROOT_ENV=${SSTOOLS_ROOT_ENV}
#export paths in main-conf
source ${SSTOOLS_ROOT_ENV}/config/config-main.conf
#export paths in user-conf
source ${SSTOOLS_ROOT_ENV}/config/config-user.conf

#extra functions to load
source ${SSTOOLS_FUNCTIONS_LIBRARY}/sstools-pipe-helpers.sh
source ${SSTOOLS_FUNCTIONS_LIBRARY}/sstools-mapfiles-helpers.sh

#echo "$@" 1>&2
#echo "$0" 1>&2
#echo "$1" 1>&2
#echo "$2" 1>&2
#echo "$3" 1>&2
#echo "$4" 1>&2
#echo "----" 1>&2

array=()
while read -rd "$sep" i; do
    array+=("$i")
done < <(printf '%s%s' "$string" "$sep")

#echo "$( IFS=$' '; echo "${userarr[*]}" )" 
#${SSTOOLS_ROOT_ENV}/modules/bash-modules/sstools-init-modules/sstools-gb-init.sh "$( IFS=$' '; echo "${userarr[*]}" )"
IFS='Â¬' read -r -a ARGS_TO_FUNC <<< $(${SSTOOLS_ROOT_ENV}/modules/bash-modules/sstools-init-modules/sstools-raw-init.sh "$@") 
#echo "${ARGS_TO_FUNC[@]}"
#ARGS_TO_FUNC=($(${SSTOOLS_ROOT_ENV}/modules/bash-modules/sstools-init-modules/sstools-raw-init.sh "$( IFS=$' '; echo "${userarr[*]}" )")) 
#echo "$@"
#ARGS_TO_FUNC=($(${SSTOOLS_ROOT_ENV}/modules/bash-modules/sstools-init-modules/sstools-raw-init.sh $@)) 
#echo "${ARGS_TO_FUNC[@]}"
RESULT=$?
#If the above (most recent command) was successful, then 
if [ $RESULT -eq 0 ]; then
  #echo "parsing complete" 1>&2
  #run script based on modifier
  if [ "$ARGS_TO_FUNC" == "" ]; then
    echo "parsing complete script no output" 1>&2
    exit 1
  else
    if [ "$sstools_modifier" == "tab-sep" ]; then
      #echo "${ARGS_TO_FUNC[@]}"
      CHECK_NUM_FIELDS_WRAPPER="${SSTOOLS_ROOT_ENV}/modules/bash-modules/check-number-of-fields-wrapper.sh"
      sh ${CHECK_NUM_FIELDS_WRAPPER} "${ARGS_TO_FUNC[@]}"
    elif [ "$sstools_modifier" == "new-header" ]; then
      #echo "${ARGS_TO_FUNC[@]}"
      AWK_CHANGE_HEADER="${SSTOOLS_ROOT_ENV}/modules/awk-modules/change-header-to-passed-argument.awk"
      cmd="awk -f ${AWK_CHANGE_HEADER} -v newHeader='${ARGS_TO_FUNC[1]}'"
      readoption "${ARGS_TO_FUNC[0]}" | eval "${cmd}"
    elif [ "$sstools_modifier" == "new-sep" ]; then
      #echo "${ARGS_TO_FUNC[@]}"
      AWK_CHANGE_SEPARATOR="${SSTOOLS_ROOT_ENV}/modules/awk-modules/change-separator.awk"
      cmd1="awk -f ${AWK_CHANGE_SEPARATOR} -vFS='\t${ARGS_TO_FUNC[3]}' -vOFS='${ARGS_TO_FUNC[1]}' "
      cmd2="awk -f ${AWK_CHANGE_SEPARATOR} -vFS='[ ]${ARGS_TO_FUNC[3]}' -vOFS='${ARGS_TO_FUNC[2]}' "
      readoption "${ARGS_TO_FUNC[0]}" | eval "${cmd1}" | eval "${cmd2}"
    else
      echo "no modifier" 1>&2
    fi
  fi
else
  echo "parsing failed" 1>&2
  exit 1
fi

